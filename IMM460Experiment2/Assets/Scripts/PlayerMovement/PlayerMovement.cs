/*
    Name: Connie Huang
    Last modified: 2023-03-24
    Code generated by ChatGPT, then tested and modified.
*/

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class PlayerMovement : MonoBehaviour
{
    public bool isFacingRight;

    private Vector3 previousPosition;
    public float movementThreshold = 0.1f;

    public float speed = 5f;
    public Color playAreaColor = Color.green;
    public Vector2[] playAreaPoints;

    private Vector3 targetPosition;

    public GameObject player;
    private Animator playerAnimator;

    bool isMoving;

    void Start()
    {
        player = GameObject.FindWithTag("Player");
        playerAnimator = player.GetComponent<Animator>();

        // Stops the player from going to the center of the screen upon running the game or switching to a new scene.
        targetPosition = this.transform.position;

        previousPosition = player.transform.position;
        isMoving = false;

        if (SceneManager.GetActiveScene().buildIndex == 9) {
            isFacingRight = true;
        } else {
            isFacingRight = PlayerPrefs.GetInt("isFacingRight", 1) == 1;
        }
        
    }

    // Draw play area in the editor
    private void OnDrawGizmos()
    {
        Gizmos.color = playAreaColor;

        if (playAreaPoints != null && playAreaPoints.Length >= 2)
        {
            for (int i = 0; i < playAreaPoints.Length; i++)
            {
                int j = (i + 1) % playAreaPoints.Length;
                Gizmos.DrawLine(playAreaPoints[i], playAreaPoints[j]);
            }
        }
    }

    void Flip()
    {
        isFacingRight = !isFacingRight; // Invert the flag
        PlayerPrefs.SetInt("isFacingRight", isFacingRight ? 1 : 0);

        // Get the object's current scale
        Vector3 theScale = player.transform.localScale;

        // Flip the object around by inverting the X scale
        theScale.x *= -1;
        player.transform.localScale = theScale;
    }

    private void Update()
    {
        
        //Tells if the player is moving in the script
        isMoving = player.transform.position != previousPosition;
        previousPosition = player.transform.position;

        if(player.transform.position.x > targetPosition.x && isFacingRight) {
            Debug.Log("player is going left");
            Flip();
        } else if (player.transform.position.x < targetPosition.x && !isFacingRight){
            Debug.Log("player is going right"); 
            Flip();
        }

        //Debug.Log(isMoving);

        if(isMoving) {
            playerAnimator.SetBool("walking", true);
        } else {
            playerAnimator.SetBool("walking", false);
        }

        // Get target position on mouse click
        if (Input.GetMouseButton(0))
        {
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            Plane groundPlane = new Plane(Vector3.forward, Vector3.zero);
            float distance;
            if (groundPlane.Raycast(ray, out distance))
            {
                Vector3 hitPoint = ray.GetPoint(distance);
                targetPosition = new Vector3(hitPoint.x, hitPoint.y, transform.position.z);
            }
        }


        // Move towards target position if inside play area
        if (IsPointInsidePlayArea(targetPosition))
        {
            //transform.position = Vector3.MoveTowards(transform.position, targetPosition, speed * Time.deltaTime);
            player.transform.position = Vector3.MoveTowards(player.transform.position, targetPosition, speed * Time.deltaTime);
            //Debug.Log("player is walking!!");
            
        } else {
            //Debug.Log("player is NOT walking - idle");
        }

        // Move towards closest point on play area edge if outside play area
        if (!IsPointInsidePlayArea(targetPosition))
        {
            Vector3 closestPoint = GetClosestPoint(targetPosition);
            //transform.position = Vector3.MoveTowards(transform.position, closestPoint, speed * Time.deltaTime);
            player.transform.position = Vector3.MoveTowards(player.transform.position, closestPoint, speed * Time.deltaTime);
            //Debug.Log("~player is walking!!");
            
        } else {
            //Debug.Log("~player is NOT walking - idle");
        }
    }

    // Check if a point is inside the play area using the ray casting algorithm
    private bool IsPointInsidePlayArea(Vector3 point)
    {
        int intersectCount = 0;

        for (int i = 0; i < playAreaPoints.Length; i++)
        {
            int j = (i + 1) % playAreaPoints.Length;

            if (((playAreaPoints[i].y <= point.y) && (point.y < playAreaPoints[j].y))
                || ((playAreaPoints[j].y <= point.y) && (point.y < playAreaPoints[i].y)))
            {
                float xIntersection = (point.y - playAreaPoints[i].y) / (playAreaPoints[j].y - playAreaPoints[i].y) * (playAreaPoints[j].x - playAreaPoints[i].x) + playAreaPoints[i].x;
                if (point.x < xIntersection)
                {
                    intersectCount++;
                }
            }
        }

        return (intersectCount % 2 == 1);
    }

    // Get the closest point on a play area edge to a given point
    private Vector3 GetClosestPoint(Vector3 point)
    {
        Vector3 closestPoint = Vector3.zero;
        float closestDistance = float.MaxValue;

        for (int i = 0; i < playAreaPoints.Length; i++)
        {
            int j = (i + 1) % playAreaPoints.Length;
            Vector3 edgeStart = playAreaPoints[i];
            Vector3 edgeEnd = playAreaPoints[j];
            Vector3 edgeClosestPoint = GetClosestPointOnEdge(point, edgeStart, edgeEnd);
            float distance = Vector3.Distance(point, edgeClosestPoint);

            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestPoint = edgeClosestPoint;
            }
        }

        return closestPoint;
    }

    private Vector3 GetClosestPointOnEdge(Vector3 point, Vector3 edgeStart, Vector3 edgeEnd)
    {
        Vector3 edgeDirection = edgeEnd - edgeStart;
        float edgeLength = edgeDirection.magnitude;
        edgeDirection /= edgeLength;
        Vector3 pointDirection = point - edgeStart;
        float dotProduct = Vector3.Dot(pointDirection, edgeDirection);

        if (dotProduct <= 0)
        {
            return edgeStart;
        }
        else if (dotProduct >= edgeLength)
        {
            return edgeEnd;
        }
        else
        {
            return edgeStart + edgeDirection * dotProduct;
        }
    }
}